# RISC-V-Hakaton
* RISC-V
1. https://github.com/MPSU/APS
2. https://github.com/ultraembedded/riscv
3. https://en.m.wikipedia.org/wiki/Hazard_(computer_architecture)#Register_forwarding
* Verilog
4. https://portal-ed.ru/index.php/uchebnik-verilog
5. https://kit-e.ru/circuit/kratkij-kurs-hdl-chast-2-1/
6. https://www.chipverify.com/verilog/verilog-tutorial
* Assembler
7. https://blic.fandom.com/ru/wiki/%D0%9A%D1%80%D0%B0%D1%82%D0%BA%D0%B8%D0%B9_%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B5%D0%BD%D1%8C_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4_%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80%D0%B0
8. http://natalia.appmat.ru/c&c++/assembler.html


Оптимизация RISC-V

Конфликты конвейера
1. Структурные конфликты
* Дублирование ресурсов
* Конвейеризация исполнительных устройств
* Изменение структуры
2. Конфликты по данным
* Чтение после записи (RAW)
* Запись после чтения (WAR)
* Запись после записи (WAW)
3. Конфликты по управлению
* Статическое предсказание переходов
* Динамическое изменение переходов
* Буферизация адресов переходов и команд из точки перехода
* Буфер цикла

Предложения нейронки по оптимизации

Fetch state

Чтобы оптимизировать код для повышения производительности на последовательной основе, мы можем исключить комбинационную логику между выходом блока выборки и вводом блока выполнения. Этого можно достичь, введя конвейерный регистр между блоком выборки и блоком выполнения.

Load and Store unit

Чтобы оптимизировать код для повышения производительности на последовательной основе, мы можем внести следующие изменения, чтобы уменьшить задержку между операциями загрузки и сохранения:
Переместите выходные данные data_we_o, data_be_o, data_addr_o и data_req_o в блок always_comb для операций сохранения, так как эти сигналы используются только для операций сохранения. Точно так же мы можем переместить вывод lsu_data_o в блок always_comb для операций загрузки.
Объедините операторы case в блоке always_comb для операций сохранения, чтобы уменьшить количество логических операций.
Объедините операторы case в блоке always_comb для операций загрузки, чтобы уменьшить количество логических операций.

GPR

Вот несколько предложений по оптимизации производительности данного кода:

Используйте меньший тип данных для wr_en_dec
Поскольку wr_en_dec — это простой сигнал включения, мы можем использовать меньший тип данных для хранения его значения. Вместо 32-битного вектора мы можем использовать 8-битный вектор (или даже меньше, в зависимости от количества регистров). Это уменьшит размер регистрового файла и улучшит производительность.
Используйте один блок always_ff для записи регистра
Вместо использования блока generate для создания нескольких блоков always_ff для каждого регистра мы можем использовать один блок always_ff с циклом для перебора всех регистров. Это упростит код и уменьшит количество логических уровней, что улучшит производительность.
Используйте неблокирующие назначения для записи в регистр
Текущий код использует блокирующие назначения для записи в регистр, что может вызвать состояние гонки и привести к неправильному поведению. Вместо этого мы должны использовать неблокирующие присваивания, которые обеспечат правильное поведение и повысят производительность.

Decode

Чтобы оптимизировать код для повышения производительности, вот несколько советов:
Используйте побитовые операции вместо использования оператора среза. Побитовые операции, такие как побитовое И (&) и побитовое ИЛИ (|), выполняются быстрее, чем операторы среза.
Уменьшите количество промежуточных сигналов. Промежуточные сигналы могут занимать много памяти и замедлять симуляцию. Постарайтесь исключить промежуточные сигналы, которые используются только один раз, и по возможности комбинируйте логические выражения.
Используйте тернарные операторы вместо операторов if-else. Тернарные операторы быстрее, чем операторы if-else, потому что они не требуют операции ветвления.
По возможности используйте константы вместо переменных. Константы могут быть оптимизированы компилятором, что может повысить производительность.

Decode stage

Тем не менее, есть несколько потенциальных областей для улучшения:
Уменьшите количество блоков always_comb:
В настоящее время в предоставленном фрагменте кода есть три блока always_comb. Эти блоки используются для вычисления значений сигналов op1 и op2 на основе значений decode_ex_op1_sel и decode_ex_op2_sel соответственно. Эти блоки always_comb будут выполняться всякий раз, когда изменяется любой из их входов. Вместо использования блоков always_comb мы можем определить op1 и op2 как переменные и вычислить их значения в одном блоке always_ff, который запускается только тогда, когда инструкция действительна и не остановлена. Это изменение может потенциально уменьшить количество логических элементов, используемых в проекте.
Упростим логику next_pc_sel:
Блок always_comb, вычисляющий next_pc_sel на основе сигналов d_branch, d_jalr и d_jal, можно упростить до одного оператора case. Кроме того, регистр по умолчанию можно удалить, поскольку он является избыточным.
Объединить задания:
Есть несколько сигналов, которым назначены отдельные блоки always_ff. Например, d_valid_o, d_op1_o и d_op2_o назначаются в отдельных операторах assign. Эти сигналы могут быть объединены в один блок always_ff, который срабатывает, когда инструкция действительна и не остановлена. Это изменение потенциально может уменьшить количество логических элементов, используемых в проекте.
Упростите блок always_ff:
Блок always_ff, который назначает сигналы конвейерного регистра, можно упростить, удалив операторы if-else и объединив назначения сигналов в один блок. Кроме того, сигналу d_prediction_ff всегда присваивается значение «0», и его можно удалить.
