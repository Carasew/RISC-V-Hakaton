# RISC-V-Hakaton
* RISC-V
1. https://github.com/MPSU/APS
2. https://github.com/ultraembedded/riscv
3. https://en.m.wikipedia.org/wiki/Hazard_(computer_architecture)#Register_forwarding
* Verilog
4. https://portal-ed.ru/index.php/uchebnik-verilog
5. https://kit-e.ru/circuit/kratkij-kurs-hdl-chast-2-1/
6. https://www.chipverify.com/verilog/verilog-tutorial
* Assembler
7. https://blic.fandom.com/ru/wiki/%D0%9A%D1%80%D0%B0%D1%82%D0%BA%D0%B8%D0%B9_%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B5%D0%BD%D1%8C_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4_%D0%B0%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80%D0%B0
8. http://natalia.appmat.ru/c&c++/assembler.html


Оптимизация RISC-V

Конфликты конвейера
1. Структурные конфликты
* Дублирование ресурсов
* Конвейеризация исполнительных устройств
* Изменение структуры
2. Конфликты по данным
* Чтение после записи (RAW)
* Запись после чтения (WAR)
* Запись после записи (WAW)
3. Конфликты по управлению
* Статическое предсказание переходов
* Динамическое изменение переходов
* Буферизация адресов переходов и команд из точки перехода
* Буфер цикла

Предложения нейронки по оптимизации

Fetch state
Чтобы оптимизировать код для повышения производительности на последовательной основе, мы можем исключить комбинационную логику между выходом блока выборки и вводом блока выполнения. Этого можно достичь, введя конвейерный регистр между блоком выборки и блоком выполнения.

Load and Store unit
Чтобы оптимизировать код для повышения производительности на последовательной основе, мы можем внести следующие изменения, чтобы уменьшить задержку между операциями загрузки и сохранения:
Переместите выходные данные data_we_o, data_be_o, data_addr_o и data_req_o в блок always_comb для операций сохранения, так как эти сигналы используются только для операций сохранения. Точно так же мы можем переместить вывод lsu_data_o в блок always_comb для операций загрузки.
Объедините операторы case в блоке always_comb для операций сохранения, чтобы уменьшить количество логических операций.
Объедините операторы case в блоке always_comb для операций загрузки, чтобы уменьшить количество логических операций.

GPR
Вот несколько предложений по оптимизации производительности данного кода:

Используйте меньший тип данных для wr_en_dec
Поскольку wr_en_dec — это простой сигнал включения, мы можем использовать меньший тип данных для хранения его значения. Вместо 32-битного вектора мы можем использовать 8-битный вектор (или даже меньше, в зависимости от количества регистров). Это уменьшит размер регистрового файла и улучшит производительность.

Используйте один блок always_ff для записи регистра
Вместо использования блока generate для создания нескольких блоков always_ff для каждого регистра мы можем использовать один блок always_ff с циклом для перебора всех регистров. Это упростит код и уменьшит количество логических уровней, что улучшит производительность.

Используйте неблокирующие назначения для записи в регистр
Текущий код использует блокирующие назначения для записи в регистр, что может вызвать состояние гонки и привести к неправильному поведению. Вместо этого мы должны использовать неблокирующие присваивания, которые обеспечат правильное поведение и повысят производительность.
